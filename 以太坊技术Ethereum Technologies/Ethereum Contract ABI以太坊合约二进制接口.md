# **Ethereum Contract ABI**
此规范现在作为[Solidity文档](https://solidity.readthedocs.io/en/develop/abi-spec.html)的一部分进行维护。
# 函数Functions
## Basic design
我们假设应用程序二进制接口（ABI）是强类型的，在编译时和静态时都是已知的，不会提供反省机制。我们断言所有合约都将具有在编译期间他们调用可用的任何合约的接口定义。  
该规范不涉及接口是动态的或仅在运行时才知道的合约。如果这些情况变得重要，那么可以充分地将其作为Ethereum生态系统内建设施来处理。
## 函数选择器Function Selector
函数调用的调用数据的前四个字节指定要调用的函数。它是函数签名的Keccak（SHA-3）哈希的第一个（左，高位[大端](http://blog.csdn.net/ce123_zhouwei/article/details/6971544)）四个字节。这个签名由基本原型的规范表达式，即具有参数类型的括号列表的函数名称定义。参数类型由单个逗号分隔，不使用空格。
## 参数编码Argument Encoding
从第五个字节开始，编码参数随之而来。这种编码也用于其他地方，例如返回值和事件参数都以相同的方式编码，但是它们没有指定函数的前四个字节。
### Types类型
以下是基本类型：

* `uint<M>`：`M`位无符号整数，`0 < M <= 256`, `M % 8 == 0` 例如 `uint32`, `uint8`, `uint256`.
* `int<M>`：`M`位二进制补码有符号整数，`0 < M <= 256`, `M % 8 == 0`.
* `address`：相当于`uint160`，除了假设的解释和语言输入。
* `uint`, `int`：`uint256`，`int256`的同义词（不能用于计算函数选择器）。
* `bool`：相当于限制为`0`和`1`的值的`uint8`
* `fixed<M>x<N>`：`M`位的有符号定点十进制数，`0 < M <= 256`, `M % 8 ==0`, 并且 `0 < N <= 80`, 也就是值 `v` 表示十进制数 `v / (10 ** N)`.
* `ufixed<M>x<N>`：无符号的 `fixed<M>x<N>`.
* `fixed`, `ufixed`：`fixed128x19`, `ufixed128x19` 的同义词（不能用于计算函数选择器）。
* `bytes<M>`：`M`字节的二进制类型，`0 <M <= 32`.
* `function`：等效于`bytes24`，一个地址后面加一个函数选择器  
  
以下是（固定大小）数组类型：

* `<type>[M]`：给定固定长度的固定长度数组。
以下是动态大小类型：  
  
* `bytes`：动态大小的字节序列。
* `string`：动态大小的unicode字符串，假定为UTF-8编码。
* `<type> []`：给定固定长度类型的可变长度数组。  

可以通过用括号包围有限非负数个类型，并以逗号分隔，组合成匿名结构体：
* `(T1,T2,...,Tn)`：由类型`T1，...，Tn，n> = 0`组成的匿名结构体（有序元组）。  
  
还可以构建结构体的结构体，结构体的数组等等。
## 编码的正式规范Formal Specification of the Encoding
我们现在将正式指定编码，使其具有以下属性，如果某些参数是嵌套数组，则特别有用：  
#### 属性
1. 访问值所需的读取次数最多为参数数组结构内的值的深度，即检索`a_i[k][l][r]`需要四次读取。在以前版本的ABI中，读取次数与最坏情况下的动态参数总数呈线性关系。

2. 变量或数组元素的数据不与其他数据交错，并且它是可重定位的，即它仅使用相对的“地址”  
  
我们区分静态和动态类型。静态类型是原位编码的，动态类型在当前区块之后的单独分配的位置进行编码。  
**定义：**以下类型是动态的：  
* `bytes`
* `string`
* `T[]` for any `T`
* `T[k]` for any dynamic `T` and any `k > 0`  
  
所有其他类型都被称为“静态”(static)。  

**定义：**`len(a)`是二进制字符串`a`中的字节数，`len(a)`的类型假定为`uint256`