# 以太坊开发教程Ethereum Development Tutorial
OUTDATED：本文档可能包含过时的信息，具体的API可能不同。[这里](https://blog.ethereum.org/2016/07/12/build-server-less-applications-mist/)可以找到最近的一个教程。  
本文的目的是介绍从开发角度来看，为了开发祝你好运和去中心化应用程序而需要了解的Ethereum的基础知识。 有关以太坊的一般介绍，请参阅[白皮书](https://github.com/ethereum/wiki/wiki/White-Paper)，有关完整的技术规格请参阅[黄皮书](http://gavwood.com/Paper.pdf)，尽管这些不是本页面的先决条件。也就是说，这篇文章是专门针对应用程序开发人员而写的Ethereme的替代介绍。
## 介绍
Ethereum是一个平台，旨在让人们轻松地使用区块链技术编写分散式应用程序（Đapps）。分散应用程序是一种为用户提供某些特定目的的应用程序，但它具有重要的属性，即应用程序本身不依赖于任何现有特定一方。 Đapp不是作为销售或提供特定方的服务的前端，而是用于在没有任何集中式中介的情况下进行交流的人或组织的工具。  
甚至于像过滤，身份管理，托管和争议解决这样的典型集中式提供商领域的必要“中介”功能也可以由网络直接处理或者开放后让任何人都可以参与，使用类似内部代币系统和声誉系统等工具来确保用户获得高质量的服务。 Đapps的早期例子包括BitTorrent的文件共享和Bitcoin的货币。Ethereum采用BitTorrent和Bitcoin中的主要开发技术，对等网络和区块链等，并将其推广到一起，以便开发人员可以将这些技术用于任何目的。  
可以将Ethereum区块链交替描述为具有内置编程语言的区块链，或作为基于共识的全局执行的虚拟机。实际处理内部状态和计算的协议部分被称为Ethereum虚拟机（EVM）。从实际的角度来看，EVM可以被认为是一个大型的分散式计算机，其中包含数百万个被称为“帐户”的对象，它们具有维护内部数据库，执行代码和交互的能力。  
有两种类型的帐户：
* **外部帐户（EOAs）**：由私钥控制的帐户，如果您拥有与EOA关联的私钥，则可以从它发送以太币和消息。
* **合约帐户**：具有自己的代码并由代码控制的帐户。  
默认情况下，以太坊执行环境是无生命的;没有任何事情发生，每个帐户的状态保持不变。然而，任何用户都可以通过从外部帐户发送交易来触发一个操作，从而将以太坊置于运动状态。如果交易的目的地是另一个EOA，那么交易可能会转移一些以太币，否则不会执行任何操作。但是，如果目的地是合约帐户，那么合约会被激活并自动运行代码。  
代码能够读/写自己的内部存储internal storage（一个映射32字节的键到32字节的值的数据库），读取接收到的消息的存储storage，并发送消息到其他合约，依次触发它们的执行。一旦执行停止，并且由合约发送的消息触发的所有子执行也停止（这一切都以确定性和同步顺序发生，即子呼叫在父调用进一步完成之前完成），则执行环境子再次停止，直到被下一次交易唤醒。  
智能合约通常有四个目的：  
* 维护一个代表对其他合约或外部世界有用的数据存储;一个例子是模拟货币的合约，另一个例子是在特定组织中记录会员资格的合约。
* 作为一种具有更复杂访问策略的外部帐户;这被称为“转发合约”，通常只有在满足某些条件时才简单地将传入消息重新发送到某个所需目的地;例如，可以是一个具有等待条件的转发合约，直到给定的三个私钥中的两个在重新发送之前确认了特定的消息（即多重签名）。更复杂的转发合约根据发送的消息的性质有不同的条件;该功能的最简单的用例是通过一些更复杂的访问过程来覆盖的撤销限制。
* 管理多个用户之间持续的合约或关系。这方面的例子包括一些金融合约，一些特定的中间人的托管或某种保险。一方也可以有一方的让任何其他方随时参与的开放合约;一个例子就是一个合约自动向提交一些数学问题有效解决方案或证明他提供了一些计算资源的人支付一笔奖励。
* 为其他合约提函数;基本上充当一个软件库。  
合约通过被称为“调用”或“发送消息”的行为彼此交互。“消息”是包含一定数量的以太币（Ethereum中使用的特殊内部货币，主要用于支付交易费用）的对象，任意大小的数据字节数组，发件人和收件人的地址。当合约收到消息时，可以选择返回一些该消息的原始发件人可以立即使用的数据。这样，发送消息就像调用一个函数一样。  
由于合约可以发挥不同的作用，我们期望合同将相互交流。 例如，考虑一个情况，即Alice和Bob赌注100 GavCoin旧金山的温度在下一年的任何时候都不会超过35ºC。然而，爱丽丝非常安全，因为她的主要帐户使用的转发合约只发送通过三个私钥中的两个的密钥发送的消息。鲍勃对于量子密码术是偏执狂，所以他使用一个转发合约，它只传递靠传统ECDSA一起签名的 [Lamport signatures](https://en.wikipedia.org/wiki/Lamport_signature) 消息（但是由于他是老式的，他更喜欢使用基于SHA256的Lamport sig版本，这个版本不直接在Ethereum上支持）。  
投注合约本身需要从一些合同中获取关于旧金山天气的数据，当需要将GavCoin实际发送给Alice或Bob（或更准确地说，Alice或Bob的转发合约）时，还需要与GavCoin合约进行交流）。 因此，我们可以显示帐户之间的关系：  
  
![Image text](https://raw.githubusercontent.com/piouslove/ethereum_zh_cn/master/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%C3%90App%20Development/img/contract_relationship.png)  
  
当鲍勃想完成下注时，会发生以下步骤：
1. 发送一个交易，触发从Bob的EOA到Bob的转发合约的消息。
2. Bob的转发合约将消息的散列和Lamport签名发送到作为Lamport签名验证库的合同。
3. Lamport签名验证库看到Bob想要一个基于SHA256的Lamport sig，所以根据需要多次调用SHA256库来验证签名。
4. 一旦Lamport签名验证库返回1，表示签名已被验证，它会向表示该投注的合约发送一条消息。
5. 下注合约Bet检查提供旧金山温度的合约Weather Feed，以查看温度。
6. 下注合约看到，消息响应表明温度高于35ºC，因此向GavCoin合约发送消息，将GavCoin从其账户移动到Bob的转发合约。  
请注意，GavCoin全部被“存储”作GavCoin合同数据库中的条目;在步骤6的上下文中，“账户”这个词仅仅意味着在GavCoin合约存储中有一个数据输入，其中有一个赌注合同的地址作为键和一个余额数量作为值。收到此消息后，GavCoin合同将此值减少一定量，并增加与Bob转发合约地址相对应的条目中的值。 我们可以在下图中看到这些步骤：  
  
![Image text](https://raw.githubusercontent.com/piouslove/ethereum_zh_cn/master/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%C3%90App%20Development/img/contract_relationship2.png)  
  
## 状态机State Machine
EVM中的计算是使用基于堆栈的字节码语言完成的，这种语言就像比特币脚本，传统程序集和Lisp（Lisp部分归因于递归的消息发送功能）之间的交叉。 EVM中的一个程序是一系列操作码，如下所示：
```
PUSH1 0 CALLDATALOAD SLOAD NOT PUSH1 9 JUMPI STOP JUMPDEST PUSH1 32 CALLDATALOAD PUSH1 0 CALLDATALOAD SSTORE
```
这个特定合同的目的是作为一个名称注册表; 任何人都可以发送一个包含64字节数据的消息，32个用于键，32个用于其值。合同检查键是否已经在存储器中注册，如果还没有，则合同在该键上注册该值。  
在执行期间，保持一个名为`memory`的无限扩展字节数组，指向当前指令的“程序计数器”PC和32字节值堆栈。 在执行开始时，`memory`和堆栈为空，PC为零。 现在，让我们假设这个代码的合同是第一次被访问，并且一个消息被发送了123 wei（1018 wei = 1 ether）和64字节的数据，其中前32个字节编码54和 第二个32字节编码2020202020。  
因此，最开始的状态是
```
PC: 0 STACK: [] MEM: [], STORAGE: {}
```
位置0处的指令是PUSH1，它将一个字节的值推送到堆栈上，并跳过代码中的两个步骤。 因此，我们有：
```
PC: 2 STACK: [0] MEM: [], STORAGE: {}
```
位置2处的指令是CALLDATALOAD，它从堆栈中弹出一个值，从该索引开始加载32个字节的消息数据，并将其推送到堆栈。 回想一下，前32个字节在这里编码54。
```
PC: 3 STACK: [54] MEM: [], STORAGE: {}
```
SLOAD从堆栈中弹出一个，并将该索引的合约存储中的值推送到堆栈。 由于合同第一次使用，所以没有任何东西，所以零。
```
PC: 4 STACK: [0] MEM: [], STORAGE: {}
```
如果值为零，则不弹出一个值并推送1，否则为0
```
PC: 5 STACK: [1] MEM: [], STORAGE: {}
```
接下来，我们PUSH1 9
```
PC: 7 STACK: [1, 9] MEM: [], STORAGE: {}
```
JUMPI指令弹出2个值，只有当第二个值不为零时跳转到第一个指定的指令。在这里，第二个是非零，所以我们跳转。如果存储索引54中的值已经不为零，则堆栈顶部的第二个值将为0（由于NOT），所以我们不会跳过，我们将提前到STOP指令导致我们停止执行
```
PC: 9 STACK: [] MEM: [], STORAGE: {}
```
这里，让我们PUSH1 32
```
PC: 11 STACK: [32] MEM: [], STORAGE: {}
```
现在，我们再次CALLDATALOAD，弹出32并从字节32开始直到字节63，将消息数据中的字节推送。
```
PC: 13 STACK: [2020202020] MEM: [], STORAGE: {}
```
下面我们PUSH1 0
```
PC: 14 STACK: [2020202020, 0] MEM: [], STORAGE: {}
```
现在，我们再次加载消息数据字节0-31（加载消息数据与加载内存memory一样便宜，所以我们不用担心将其保存在内存memory中）
```
PC: 16 STACK: [2020202020, 54] MEM: [], STORAGE: {}
```
最后，我们SSTORE在存储中保存索引54的值2020202020
```
PC: 17 STACK: [] MEM: [], STORAGE: {54: 2020202020}
```
在步骤17，没有指令，所以我们停止。如果堆栈stack或内存memory中有任何东西，它将被删除，但是存储storage将保留，并在下一次有人发送消息时可用。因此，如果此消息的发送者再次发送相同的消息（或者可能有人尝试重新注册54到3030303030），则下一次步骤7的`JUMPI`将不会处理，并且执行将在第8步提前停止。  
幸运的是，您不必在低级程序集中编程; 存在一种高级语言，特别为编写智能合约而设计，称为“Solidity”，使您更容易编写合同（还有其他几个，包括LLL，Serpent和Mutan，您可能会根据你的经验发现更容易选择学习或使用它们）。您以这些语言编写的任何代码都将编译成EVM，并在你发送包含EVM字节码交易的时候创建合约。  
有两种类型的交易transaction：发送交易和合约创建交易。发送交易是标准交易，包含接收地址，以太币数量，数据字节和一些其他参数，以及来自与发送者帐户相关联的私钥的签名。合约创建交易看起来像标准交易，但接收地址为空。当合同创建交易进入区块链时，交易中的数据被解释为EVM代码，EVM执行返回的值被视为新合同的代码;因此，您可以在初始化期间执行某些交易。新合同的地址根据发送地址和发送帐户之前进行的交易次数进行确定性计算（此值称为帐户随机数，也由于无关安全原因而被保留）。因此，您需要放入区块链以产生上述名称注册表的完整代码如下：
```
PUSH1 16 DUP PUSH1 12 PUSH1 0 CODECOPY PUSH1 0 RETURN STOP PUSH1 0 CALLDATALOAD SLOAD NOT PUSH1 9 JUMPI STOP PUSH1 32 CALLDATALOAD PUSH1 0 CALLDATALOAD SSTORE
```
键操作码是CODECOPY，将从字节12开始的16个字节的代码复制到从索引0开始的内存中，RETURN返回内存字节0-16，即代码字节12-28（随意在纸上手动执行执行，以验证代码和内存的这些部分是否实际上被复制和返回）。当然，代码字节12-28是我们上面看到的实际代码。
## Gas
EVM工作方式的一个重要方面是EVM内执行的每一个操作实际上是由每个完整节点共同执行的。这是Ethereum 1.0共识模型的必要组成部分，并且有益于EVM上的任何合约都可以以几乎零的成本调用任何其他合约，但也具有EVM计算步骤非常昂贵的缺点。大致来说，一个很好的对使用方法的理解是，你在EVM无法做的事情就像你在1999年以前在智能手机上无法做的事情一样。EVM可接受的用法包括运行业务逻辑（“如果是这样”）并验证签名和其他加密对象;其上限是验证其他区块链的部分（例如一个去中心化以太币和比特币的交易所）的应用程序;不可接受的用途包括使用EVM作为文件存储，电子邮件或文本消息传递系统，与图形界面有关的任何内容，以及最适合云计算（如遗传算法，图形分析或机器学习）的应用程序。  
为了防止故意的攻击和滥用，Ethereum协议要求每个计算步骤收费。费用是市场化的，虽然在实践中是强制性的;对块中可以包含的操作数量的浮动限制甚至可以让能够负担得起的交易的矿工接近无成本收取与整个交易的交易成本相称的费用(a floating limit on the number of operations that can be contained in a block forces even miners who can afford to include transactions at close to no cost to charge a fee commensurate with the cost of the transaction to the entire network);有关费用和区块运行限制系统的经济基础的更多细节，请参阅白皮书部分。  
收费方式如下，每个交易必须包含与其他数据一起的`GASPRICE`和`STARTGAS`值。`STARTGAS`是交易赋值的gas数量，`GASPRICE`是交易为每单位gas支付的费用; 因此，当交易发送时，评估过程中完成的第一件事是从发送账户余额中减去`STARTGAS * GASPRICE` wei加上交易金额的和。 `GASPRICE`由交易发送者设置，但矿工们可能会拒绝处理`GASPRICE`过低的交易。  
Gas可以大致被认为是计算步骤的计数器，并且是交易执行期间存在的但不在其外部的东西。当交易执行开始时，剩余gas设置为`STARTGAS - 21000 - 68 * TXDATALEN`，其中`TXDATALEN`是交易数据中的字节数（注意：由于长字符串零字节的较大压缩性，零字节仅花费4个gas）。每个计算步骤，从总数中减去一定量（通常为1，有时更多取决于操作）。如果gas下降到零，则所有执行恢复，但交易仍然有效，发件人仍然需要为gas支付费用。如果交易执行完成，有`N> = 0` 的gas剩余，则发送账户将被退还给`N * GASPRICE` 个`wei`以太币。  
在合约执行期间，当合约发送消息时，该消息调用自身是具有gas限制的，并且子执行以相同的方式工作（即它可能会用尽gas并还原状态或成功执行并返回值）。如果子执行超出gas（out of gas,欠费以至于不再执行），则父执行也将超出gas;因此，如果您在次级执行中设定了gas限制，则合约调用另外一个合约是完全“安全的”。如果子执行有一些gas剩余，则这些gas被退回到父执行继续使用。  
## 虚拟机操作码Virtual machine opcodes
可以在黄皮书中找到EVM中完整的操作码列表。请注意，高级语言通常会有自己对这些操作码的封装，有时具有非常不同的接口。
## 以太坊基础Basics of the Ethereum Blockchain
以太坊区块链（或“分类帐”）是去中心化的，大量复制的数据库，其中存储所有帐户的当前状态。这个区块链使用一个称为[Patricia树](https://github.com/ethereum/wiki/wiki/Patricia-Tree)（或“trie”）的数据库来存储所有帐户; 这本质上是一种特殊的Merkle树，它充当通用键/值存储。像一个标准的Merkle树一样，Patricia树有一个“根哈希”，可以用来指代整个树，不改变根哈希树的内容就不能修改。对于每个帐户，树存储一个包含`[account_nonce，ether_balance，code_hash，storage_root]`	的4元组，其中`account_nonce`是从帐户发送的交易数（保留以防止重播攻击），`ether_balance`是帐户的余额，`code_hash`如果帐户是合同则为代码的哈希值否则为`""`，而`storage_root`是存储storage数据的另一个Patricia树的根。  
  
![Image text](https://raw.githubusercontent.com/piouslove/ethereum_zh_cn/master/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%C3%90App%20Development/img/chaindiag.png)  
  
每一分钟，一个矿工生产一个新的区块（Ethereum中的采矿概念与比特币完全相同;有关更多信息，请参阅任意Bitcoin教程），该区块包含自上一个区块以来发生的交易列表和代表新状态（“状态树”）的Patricia树的根散列以及给予矿工以创造区块的以太币奖励。  
由于Patricia树的工作方式，如果几乎没有改变，树的大部分部分将与上一个区块完全相同;因此，不需要存储数据两次，因为新树中的节点将能够简单地指向在新树和旧树完全相同的地方的旧树节点中的内存地址。如果在区块N和区块N + 1之间改变了数千条数据，即使树的总大小是十亿字节，但区块N + 1需要存储的新数据量最多为几百千字节，实际上大大减少了数据量（特别是如果同一合约内发生多次变更）。每个区块都包含前一个区块的散列（这就是区块链的由来）以及一些辅助数据，如区块号、时间戳、矿工地址和gas限制。
## 图形界面Graphical Interfaces (OUTDATED API)
合约本身是一件强大的东西，但它不是一个完整的Đapp。相反，Đapp被定义为合约和方便合约使用的图形界面的组合（注意：这只适用于现在; Ethereum的未来版本将包括whisper，这是一个允许在Đapp中不通过区块链，节点互相之间直接发送消息的协议）。现在，该界面被实现为一个HTML/CSS/JS网页，具有特殊的Javascript API，用于与Ethereum区块链一起使用的`eth`对象。 Javascript API的关键部分如下：  
* `eth.transact(from, ethervalue, to, data, gaslimit, gasprice)` - 从期望的地址（注意：`from`必须是私钥，`to`必须是十六进制形式的地址）将期望的参数发送到期望的地址
* `(string).pad(n)` - 将一个编码为字符串的数字转换为n个字节长的二进制形式
* `eth.gasPrice` - 返回当前gas价格
* `eth.secretToAddress(key)` - 将私钥转换为地址
* `eth.storageAt(acct, index)` - 返回期望帐户的期望索引的存储条目
* `eth.key` - 用户的私钥
* `eth.watch(acct, index, f)` - 给定帐户的给定存储条目变动时调用`f`  
您不需要任何特殊的源文件或库来使用`eth`对象;但是，您的Đapp仅在Ethereum客户端上打开时才能工作，而不是常规的Web浏览器。有关实际使用的Javascript API的示例，请参阅[此网页的源代码](http://gavwood.com/gavcoin.html)。
## 需要持续关注的细节Fine Points To Keep Track Of
See https://github.com/ethereum/wiki/wiki/Subtleties